import org.gradle.tooling.GradleConnector
import org.gradle.tooling.model.GradleProject
import org.gradle.tooling.model.eclipse.EclipseProject

task runTask << {
    def builder = GradleConnector.newGradleConnectionBuilder()
    builder.embeddedCoordinator(true)
    builder.useClasspathDistribution()

    def buildIdentities = []
    rootProjectDirectories().each {
        println "Adding project $it.absolutePath to composite"
        def participant = GradleConnector.newGradleBuildBuilder().forProjectDirectory(it).useInstallation(gradle.gradleHomeDir).create()
        buildIdentities << participant.toBuildIdentity()
        builder.addBuild(participant)
    }
    def connection = builder.build()

    def buildLauncher = connection.newBuild(buildIdentities.iterator().next())
    buildLauncher.forTasks("jar")
    buildLauncher.run()
}

task printModel << {
    def builder = GradleConnector.newGradleConnectionBuilder()
    builder.embeddedCoordinator(true)
    builder.useClasspathDistribution()
    rootProjectDirectories().each {
        println "Adding project $it.absolutePath to composite"
        def participant = GradleConnector.newGradleBuildBuilder().forProjectDirectory(it).useInstallation(gradle.gradleHomeDir).create()
        builder.addBuild(participant)
    }
    def connection = builder.build()

    def eclipseProjects = connection.getModels(EclipseProject).collect { it.model }
    def rootProjects = eclipseProjects.grep({ findRootProject(it) == it }).sort({ it.projectDirectory })
    rootProjects.each { rootProject ->
        renderEclipseProject("", rootProject)
    }

    def gradleProjects = connection.getModels(GradleProject).collect { it.model }
    gradleProjects.each { gradleProject ->
        println "GradleProject: " + gradleProject.path
    }

    def publicationResults = connection.getModels(org.gradle.tooling.model.gradle.ProjectPublications)
    publicationResults.each { publicationResult ->
        println "Pubs: " + publicationResult.projectIdentity + " :: " + publicationResult.model.publications*.id
    }

    def buildEnvironments = connection.getModels(org.gradle.tooling.model.build.BuildEnvironment).collect { it.model }
    buildEnvironments.each { env ->
        println "Env: gradleVersion=${env.gradle.gradleVersion}, javaHome=${env.java.javaHome}"
    }
}

def rootProjectDirectories() {
    file("demo.composite").readLines().collect { new File(it) }
}

def findRootProject(project) {
    if (project.parent) {
        return findRootProject(project.parent)
    }
    return project
}

def renderEclipseProject(indent, eclipseProject) {
    renderEclipseProjectSummary(indent, eclipseProject)
    renderEclipseProjectDependencies(indent, eclipseProject)
    eclipseProject.children.each { child ->
        renderEclipseProject(indent + " ", child)
    }
}

def renderEclipseProjectSummary(indent, eclipseProject) {
    def rootProject = findRootProject(eclipseProject)
    def gradleProject = eclipseProject.gradleProject
    def participantDir = rootProject.gradleProject.projectDirectory.absolutePath - file("projects").absolutePath - "/"
    println "${indent}${participantDir}:${gradleProject.path} (${gradleProject.name})"
}

def renderEclipseProjectDependencies(indent, project) {
    project.classpath.each { externalDependency ->
        def module = externalDependency.gradleModuleVersion
        if (module!=null) {
            renderDependency(indent, "module ${module.group}:${module.name}:${module.version}")
        } else {
            renderDependency(indent, "file " + externalDependency.file)
        }
    }
    project.projectDependencies.each { projectDependency ->
        renderDependency(indent, "project " + projectDependency.path)
    }
}

def renderDependency(indent, dependency) {
    println "${indent}> depends on ${dependency}"
}

defaultTasks = [ "printModel" ]
